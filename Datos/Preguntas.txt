001;Indique cual de los siguientes enunciados es verdadero:
En un arreglo a[10], a es un puntero que apunta a la primera casilla del arreglo.;Para pasar datos por referencia en funciones se necesitan punteros.;Un puntero es un tipo de dato que almacena la direccion de memoria de otra variable.
Para asignar a un puntero int* a, la direccion de una variable int b, hacemos: a=*b.;Los punteros son un tipo de dato abstracto.;Las variables definidas en la funcion main son globales, por lo que se almacenan en la zona static.;int* a[10] crea un arreglo de 10 enteros.;Los punteros permiten el paso de datos por valor a funciones.;Al modificar la direccion referenciada por un puntero, tambien se modifica la direccion del dato referenciado.;En la zona de memoria “stack” es posible que se formen huecos de memoria sin reservar.
002;En relacion a los arreglos se puede decir que:
Se pueden inicializar de manera estatica o dinamica.;a[2] es equivalente a *(a+2).;Para inicializarlos de manera dinamica se debe reservar la memoria correspondiente en la zona de memoria Heap.;En un arreglo a[10], a es un puntero que apunta a la primera casilla del arreglo.
La operacion malloc permite inicializar un arreglo con ceros (0).;Luego de terminar de usar un arreglo estatico es necesario liberar la memoria usando free.;Arreglos estaticos se almacenan en la zona de memoria Heap.;Los arreglos se deben pasar a las funciones por valor.
003;En relacion al manejo de memoria en C, se puede decir que:
Todas las variables locales se almacenan en la misma zona de memoria.;Los datos de un arreglo se almacenan en memoria de manera consecutiva.
El error “stack overflow” ocurre cuando se generan demasiadas variables locales llenando el Stack de memoria.;En la zona de memoria “stack” es posible que se formen huecos de memoria sin reservar.;Las variables definidas en la funcion main son globales, por lo que se almacenan en la zona static.
201;Indique las operaciones que necesitan recorrer la estructura correspondiente en cada caso:
Buscar un dato especifico en una lista enlazada.;Insertar al final en una lista enlazada doble con puntero acceso apuntando al primer nodo.;Eliminar el ultimo elemento de una lista enlazada circular.;Insertar entremedio en un arreglo.
Acceder al i-esimo elemento en un arreglo.;Insertar al principio en una lista enlazada simple.;Insertar al final en una lista enlazada circular.;Insertar al final en un arreglo circular.;Insertar en una cola.
202;En relacion a la implementacion de las pilas usando arreglos es correcto decir que:
El ultimo elemento ingresado se encuentra en la primera casilla del arreglo.
Para vaciar la pila basta con modificar el indice top a -1.;Al crear la pila se crea un arreglo dinamico con una capacidad inicial (por ejemplo 10 elementos).;Al eliminar un elemento, el indice top se corre una casilla a la izquierda.
203;En relacion a la lista enlazada simple circulares (asumiendo que el puntero de acceso apunta al ultimo nodo), podemos decir que:
Ofrece exactamente las mismas ventajas que una lista enlazada simple con punteros de acceso al principio y al final.;Permite una eliminacion eficiente del primer nodo.;Ofrece un acceso eficiente (rapido) al ultimo nodo.;Ofrece un acceso eficiente (rapido) al primer nodo.;Permite una insercion eficiente (rapida) al final.
Se usa para implementar pilas.;Permite una eliminacion eficiente (rapida) del ultimo nodo.;Permite una busqueda mas rapida de elementos.;Ofrece ventajas cuando queremos recorrer la lista varias veces.;Permite una busqueda mas rapida de elementos.
204;Al comparar arreglos y listas enlazadas a la hora de implementar una Lista, se puede decir que:
Un arreglo es una buena alternativa para implementar pilas y colas.;El arreglo permite un acceso mas eficiente/rapido al i-esimo elemento.;Un arreglo es una buena alternativa para implementar un lista cuando NO necesitamos o eliminar elementos intermedios.;El arreglo ofrece ventajas y desventajas al compararse con una lista enlazada doble.
El arreglo permite una eliminacion mas eficiente/rapida del i-esimo elemento.;El arreglo es mucho mas eficiente/rapido a la hora de buscar un dato determinado.;Un arreglo generalmente ocupa menos memoria que la lista enlazada.;Las lista enlazada doble circular es la estructura mas recomendada para implementar una Lista.
205;En relacion a la implementacion usando arreglos se puede decir que:
Al implementar una pila, el arreglo se va llenando de izquierda a derecha.;Un arreglo se transforma en “circular” si consideramos que luego de la ultima casilla volvemos a la primera.;Cuando insertamos un dato en un arreglo lleno, debemos redimensionarlo.;Se suelen utilizar para implementar pilas y colas.;Al implementar una cola usando arreglos, cuando se llena el arreglo, es necesario aumentar su capacidad y reubicar los elementos.;Al implementar una cola usando arreglos, cuando se inserta un elemento, el indice del final se corre a la izquierda.
Al implementar una cola usando arreglos, para eliminar un elemento debemos mover todos los elementos que siguen una posicion hacia la izquierda.;Al implementar una pila, el elemento top corresponde al primer elemento del arreglo.;Para eliminar un elemento de un arreglo es necesario cambiar su valor a NULL.;Son mejores que las listas enlazadas.;Cuando insertamos un dato en un arreglo siempre debemos redimensionarlo.;Cuando eliminamos un dato de un arreglo debemos redimensionarlo.;Al implementar una cola usando arreglos, cuando se elimina un elemento, el indice del inicio se debe correr hacia la izquierda.;Al implementar una cola usando arreglos, cuando el indice del inicio llega a 0 y se borra un elemento es necesario cambiarlo a N-1.
206;En relacion a la implementacion de colas y pilas usando arreglos, es incorrecto decir que:
En la cola se usa un puntero al final para acceder al ultimo elemento.
En ambos casos se hace uso de indices para indicar posiciones clave (ejemplo: comienzo, fin, top).;Para implementar una cola se puede usar un arreglo circular.;Para implementar la pila, los elementos se ordenan de izquierda a derecha en el arreglo.
301;Indique cual de los siguientes enunciados es falso:
Hacer un bucle que itera n veces sobre otro bucle que realiza m iteraciones tiene complejidad O(n+m).;La complejidad temporal de 1000nlogn + n^2 es O(nlogn).;Eliminar el primer dato de una lista enlazada simple tiene complejidad O(n).;La busqueda binaria en un arreglo ordenado tiene complejidad O(nlogn).;Insertar n elementos ordenados en una lista enlazada tiene complejidad O(n).;El algoritmo mas eficiente para sumar los elementos de la secuencia: 1+2+…+n tiene complejidad O(n^2).;El algoritmo mas eficiente para ordenar un conjunto de datos tiene complejidad O(n).;La complejidad de insertar un elemento en una cola es O(n).;La complejidad temporal de blanco3n^2+m^2 es blancoO(n+m).;La eliminacion de un nodo apuntado por el current en una lista enlazada simple tiene complejidad O(1).
La complejidad de 2 bucles llamados de manera secuencial es igual a la complejidad del bucle con mayor complejidad.;La complejidad temporal de 5^n+n^5 es O(5^n).;Ordenar los datos de una lista enlazada usando el ordenamiento burbuja tiene complejidad O(i).;Llamar 10 veces a una funcion con complejidad lineal tiene complejidad O(n).;La complejidad temporal de n+n^2+n^3 es O(n^3).;La complejidad de un bucle for(i=0;i<n;i=i*2) que en cada iteracion llama a una operacion con complejidad lineal tiene complejidad O(nlogn).;Llamar n veces a una funcion con complejidad constante tiene complejidad O(n).;Buscar el mayor elemento en un arreglo ordenado tiene complejidad O(1).;Acceder al i-esimo dato de una lista enlazada tiene complejidad O(i).;La complejidad temporal de 5(n+1)/(n−1) es O(1).;La complejidad temporal de n+n^2+n^3 es O(n^3).;La operacion calloc tiene complejidad lineal en el tamanho del arreglo.
302;En relacion a la tabla hash podemos decir que:
Almacena datos de manera desordenada.;La funcion hash permite saber la posicion en donde deberia encontrarse un dato.;Tener una tabla hash con un porcentaje ocupado por sobre el recomendable, puede provocar un aumento considerable en el numero colisiones.;Es eficiente en la busqueda.;Entre mas elementos tenga la tabla hash, mayor es la probabilidad de que ocurran colisiones.;Es conveniente agrandar la tabla hash antes de que llegue a su capacidad.
Es eficiente en la busqueda de datos ordenados.;La funcion hash agranda la tabla cuando se ocupan todas las casillas disponibles.;Es conveniente ocupar toda la capacidad de la tabla, para utilizar toda la memoria disponible.
303;En relacion a la busqueda en una tabla hash podemos decir que:
Hace uso de la funcion hash y de un metodo de resolucion de colisiones.;En caso de colision, debe aplicar el mismo metodo de resolucion de colisiones utilizado en la insercion.;Se detiene al llegar a una casilla vacia.;Antes de retornar un dato debe verificar que la clave coincida con la que se busca.;Su complejidad temporal promedio es O(1), ya que la funcion hash permite encontrar rapidamente la posicion en donde probablemente se encuentra el dato.;Al llegar a una casilla vacia, el metodo asegura que el dato no se encuentra en la tabla.
Su complejidad temporal es O(log n) ya que los datos se encuentran ordenados.;Retorna directamente el dato que se encuentra en la posicion entregada por la funcion hash.;En caso de colision, su complejidad temporal es lineal (en promedio) ya que se debe recorrer el arreglo hasta encontrar el dato.;Se detiene al llegar a un dato con clave distinta a la que se busca.;Antes de retornar un dato debe verificar que el valor coincida con la que se busca.
304;En relacion al TDA Mapa podemos decir que:
No permiten almacenar claves repetidas.;Para almacenar datos con claves repetidas, se pueden usar listas para agrupar estos datos.;Se puede implementar usando una lista enlazada, aunque seria bastante lento en realizar operaciones.;Se puede usar para clasificar datos en distintas categorias;Es recomendable usarlo cuando necesitamos buscar elementos en base a un criterio determinado.;Se puede usar para contar las ocurrencias de palabras en un texto.;La eficiencia temporal de sus operaciones depende de su implementacion.;Un metodo de resolucion de colisiones podria consistir en buscar la siguiente casilla vacia a partir de la retornada por la funcion hash.
Es recomendable usarlo si queremos almacenar elementos con una secuencia determinada.;Es recomendable usarlo si queremos acceder rapidamente al ultimo elemento ingresado.;Es recomendable debido a la rapidez de sus operaciones.
305;En relacion a las colisiones en la tabla hash podemos decir que:
Si el metodo de resolucion de colisiones encuentra una casilla nula, quiere decir   que el dato no existe.;Las colisiones ocurren cuando la funcion hash nos entrega la posicion de una casilla ocupada.;Existen distintos metodos de resolucion de colisiones.;Si hay colision se aplica un metodo para resolver el problema.
Si al insertar un dato se produce una colision, se crea un nuevo nodo e inserta el dato al final de la tabla.;Si hay colision se aumenta el tamanho de la tabla.;Si al insertar un dato se produce una colision, entonces se sobreescribe el dato de la tabla.;Ocurre cuando se insertan dos claves iguales en la tabla.;Esto no puede ocurrir. La funcion retorna valores distintos para claves distintas.
306;En relacion a la funcion hash podemos decir que:
Retorna un numero entero.;Una buena funcion hash dispersa los datos dentro de la tabla.;Una funcion hash valida consiste en retornar una constante (por ejemplo: return 0).;Una buena funcion hash consiste en multiplicar la clave por un numero decimal y luego usar los decimales del resultado para obtener el valor.;Retorna una posicion para el dato que se quiere ingresar.;Transforma una variable en un numero entero.
Retorna la clave del dato que se quiere ingresar.;Busca una casilla disponible (vacia) para insertar el dato.;Una funcion hash podria consistir en retornar un numero aleatorio.;Puede retornar cualquier tipo de dato (void*).;Una buena funcion hash no genera colisiones.;Una buena funcion hash no deberia causar colisiones.
501;En relacion a la cola con prioridad podemos decir que:
Es adecuada si queremos acceder (modificar/eliminar) el dato con mayor indice de prioridad.;Se puede usar para almacenar nodos al recorrer un grafo. La cola permitiria seleccionar el nodo "mas prometedor" en cada iteracion.;"Insertar" es una operacion fundamental en una cola.;Podria ser implementada de manera eficiente usando un arbol binario de busqueda.
Es adecuada para buscar datos por prioridad.;Es una estructura de datos que permite acceder al dato con mayor prioridad con complejidad O(1).;Es eficiente para realizar busquedas por prioridad: O (log n).
502;En relacion a un monticulo binario de maximos podemos decir que:
Es un arbol binario que se implementa usando un arreglo.;El monticulo es altamente efectivo cuando lo unico que necesito es guardar datos y acceder o eliminar el que tiene mayor prioridad.;El segundo mayor elemento deberia encontrarse en el segundo nivel del arbol (justo por debajo del nodo raiz).;En el caso promedio, la insercion es O(1).
Encontrar tanto el mayor como el menor elemento se realiza de manera mas eficiente que la eliminacion.;Es eficiente para realizar busquedas por prioridad.;Comparado con un arreglo ordenado por prioridad, la ventaja del monticulo tiene que ver con la eliminacion de elementos.
503;En relacion al arbol B/B+ es correcto decir que:
Al eliminar, es posible que se produzcan "fusiones" entre nodos hermanos.;El camino desde la raiz a cualquier clave tiene la misma longitud.;La eliminacion de un dato en un arbol B tiene complejidad temporal promedio O(log N).;Se recomienda usar un arbol B cuando se tienen datos de gran tamanho y no caben en la memoria principal (ejemplo fotografias, videos, musica).
Es recomendable usar un arbol B/B+ cuando los nodos del arbol se encuentran almacenados en la memoria principal(disco duro).;Debido a su baja altura, la eliminacion en un arbol es mas eficiente que la insercion.;Al insertar en un arbol B/B+ se generan nuevos nodos hoja.
504;Indique la alternativa verdadera.
El peor caso para un arbol de busqueda no balanceado ocurrira si insertamos los datos en orden creciente o decreciente.;La operacion next de una tabla hash, de una lista y de un arbol binario tienen la misma complejidad temporal promedio: O(1).;Buscar una prioridad especifica en un monticulo binario de maximos tiene complejidad O(N).;La cola por prioridad puede ser usada para gestion de impresiones enviadas.
Es recomendable usar arbol B/B+ cuando si los nodos se encuentran almacenados en la RAM.;Los nodos hojas son los nodos que se encuentran al inicio de cada rama.;La cola por prioridad puede ser usada como lista enlazada.