001;Indique cual de los siguientes enunciados es verdadero:
En un arreglo a[10], a es un puntero que apunta a la primera casilla del arreglo.;Para pasar datos por referencia en funciones se necesitan punteros.;Un puntero es un tipo de dato que almacena la direccion de memoria de otra variable.
Para asignar a un puntero int(puntero) a, la direccion de una variable int b, hacemos: a=(puntero)b.;Los punteros son un tipo de dato abstracto.;Las variables definidas en la funcion main son globales, por lo que se almacenan en la zona static.;int(puntero) a[10] crea un arreglo de 10 enteros.;Los punteros permiten el paso de datos por valor a funciones.;Al modificar la direccion referenciada por un puntero, tambien se modifica la direccion del dato referenciado.;En la zona de memoria STACK es posible que se formen huecos de memoria sin reservar.
002;En relacion a los arreglos se puede decir que:
Se pueden inicializar de manera estatica o dinamica.;a[2] es equivalente a x (a+2).;Para inicializarlos de manera dinamica se debe reservar la memoria correspondiente en la zona de memoria Heap.;En un arreglo a[10], a es un puntero que apunta a la primera casilla del arreglo.
La operacion malloc permite inicializar un arreglo con ceros (0).;Luego de terminar de usar un arreglo estatico es necesario liberar la memoria usando free.;Arreglos estaticos se almacenan en la zona de memoria Heap.;Los arreglos se deben pasar a las funciones por valor.
003;En relacion al manejo de memoria en C, se puede decir que:
Todas las variables locales se almacenan en la misma zona de memoria.;Los datos de un arreglo se almacenan en memoria de manera consecutiva.
El error STACK OVERFLOW ocurre cuando se generan demasiadas variables locales llenando el Stack de memoria.;En la zona de memoria STACK es posible que se formen huecos de memoria sin reservar.;Las variables definidas en la funcion main son globales, por lo que se almacenan en la zona static.
101;En relacion a una lista enlazada es correcto decir que:
Es una estructura de datos que permite la implementacion de distintas operaciones.;Cada nodo se compone de un dato y uno o dos punteros.;Es una estructura de datos.;Se puede acceder a traves de un puntero al primer elemento.;Permite almacenar una secuencia de elementos del mismo tipo.;Permite acceder directamente al ultimo dato accedido usando el puntero current.
Permite acceder directamente al dato que estamos buscando a traves del puntero current.;El primer nodo puede almacenar informacion adicional de la lista como su tamanho y el puntero current.;Es un TDA.;Se recomienda que la lista enlazada tenga mas nodos que datos para evitar colisiones.;Permite acceder directamente a los datos que se buscan gracias al puntero current.
102;En relacion a la pila y cola se puede decir que:
Pilas y colas no se pueden recorrer.;Ambas permiten insertar, eliminar y acceder a elementos.;Ambas permiten almacenar y realizar operaciones en un conjunto de datos.;Ambas son TDAs.;Si una impresora mantuviera los documentos a imprimir en una pila, probablemente generaria problemas entre los usuarios.;Para acceder al primer elemento ingresado en una pila es necesario remover todos los otros elementos.;Las listas permiten realizar las mismas operaciones que pilas y colas juntas.
Ambas son estructuras de datos.;En una cola se puede acceder directamente a un elemento especifico, por ejemplo el 4to elemento.;La opcion deshacer en un editor de texto se puede implementar usando una cola.;Se recomienda usar listas, en vez de pilas o colas, debido a su amplia gama de funcionalidades.
103;En relacion a la implementacion (codificacion) del TDA Lista en C es correcto decir que:
Las funciones de la lista deben recibir un puntero a la lista como parametro para poder acceder a sus variables.;El archivo (puntero).h permite al USUARIO DE TDAs de la lista conocer las operaciones implementadas, los parametros de entrada y lo que retornan.;El archivo (puntero).h permite al DESARROLLADOR DE TDAs conocer las operaciones que se deben implementar, sus parametros de entrada y lo que deberian retornan.
La unica manera de conocer el tamanho de una lista es almacenando en su estructura una variable size que se actualice cada vez que se insertan/eliminan elementos.;Si queremos usar dos listas: una para guardar numeros y otra para guardar strings, es necesario implementar dos TDAs Lista en distintos archivos.;La codificacion del TDA se realiza en el archivo main.c.;Para usar un TDA es necesario conocer la estructura de datos subyacente.;Al construir la lista es necesario inicializar sus variables a NULL y crear el primer nodo. No es necesario crear un nodo al inicializar la lista enlazada;Para hacer una lista de peliculas, debemos agregar a la estructura Pelicula un puntero a la siguiente pelicula.
104;En relacion a los Tipos de Dato Abstracto (TDAs) podemos decir que:
Consisten en un conjunto de operaciones definidas para una coleccion de datos.;Son definidos por su comportamiento desde el punto de vista de USUARIO.;Se implementan utilizando estructuras de datos.;Si son usados correctamente facilitan la comprension del codigo.
La siguiente definicion corresponde a un TDA:  secuencia de elementos donde cada elemento se compone de un valor y un puntero al siguiente elemento, y se accede a los elementos a traves del puntero INICIO.;Un TDA debe especificar detalladamente la organizacion interna de sus datos y la manera en que funcionan sus operaciones.;Las funcionalidades de un TDA dependen de la estructura de datos usada para implementarlo.;Los arreglos son un ejemplo de TDA.;La siguiente definicion corresponde a un TDA: coleccion de numeros para los que se definen las operaciones de union, interseccion y pertenencia.
105;En relacion al TDA Lista es INCORRECTO decir que:
Para eliminar un elemento de una Lista debemos conectar el anterior con el siguiente.;Para insertar al final de una Lista es necesario recorrerla.;Siempre es mejor usar listas que pilas o colas.
Se puede implementar usando listas enlazadas o arreglos;A diferencia de pilas o colas, las listas se pueden recorrer.;Un Lista se podria usar COMO SI FUERA una Pila o Cola.;Permite almacenar una secuencia de datos del mismo tipo.;Permite realizar inserciones o eliminaciones en cualquier parte de la secuencia.;Una lista no es lo mismo a una lista enlazada. La primera es un TDA, la segunda una estructura de datos.
106;En relacion a las operaciones que se pueden realizar en una lista enlazada es INCORRECTO decir que:
Las desventaja de una lista enlazada circular es que no se puede saber donde termina.
Para eliminar el nodo apuntado por el current en una lista enlazada simple, debemos recorrer la lista para obtener el nodo anterior al current;Para eliminar debemos enlazar el nodo anterior al current con el siguiente.;Para buscar un dato especifico es necesario recorrer la lista enlazada.;En una lista enlazada circular con un elemento el unico nodo de la lista apunta a si mismo.
201;Indique las operaciones que necesitan recorrer la estructura correspondiente en cada caso:
Buscar un dato especifico en una lista enlazada.;Insertar al final en una lista enlazada doble con puntero acceso apuntando al primer nodo.;Eliminar el ultimo elemento de una lista enlazada circular.;Insertar entremedio en un arreglo.
Acceder al i-esimo elemento en un arreglo.;Insertar al principio en una lista enlazada simple.;Insertar al final en una lista enlazada circular.;Insertar al final en un arreglo circular.;Insertar en una cola.
202;En relacion a la implementacion de las pilas usando arreglos es correcto decir que:
El ultimo elemento ingresado se encuentra en la primera casilla del arreglo.
Para vaciar la pila basta con modificar el indice top a -1.;Al crear la pila se crea un arreglo dinamico con una capacidad inicial (por ejemplo 10 elementos).;Al eliminar un elemento, el indice top se corre una casilla a la izquierda.
203;En relacion a la lista enlazada simple circulares (asumiendo que el puntero de acceso apunta al ultimo nodo), podemos decir que:
Ofrece exactamente las mismas ventajas que una lista enlazada simple con punteros de acceso al principio y al final.;Permite una eliminacion eficiente del primer nodo.;Ofrece un acceso eficiente (rapido) al ultimo nodo.;Ofrece un acceso eficiente (rapido) al primer nodo.;Permite una insercion eficiente (rapida) al final.
Se usa para implementar pilas.;Permite una eliminacion eficiente (rapida) del ultimo nodo.;Permite una busqueda mas rapida de elementos.;Ofrece ventajas cuando queremos recorrer la lista varias veces.;Permite una busqueda mas rapida de elementos.
204;Al comparar arreglos y listas enlazadas a la hora de implementar una Lista, se puede decir que:
Un arreglo es una buena alternativa para implementar pilas y colas.;El arreglo permite un acceso mas eficiente/rapido al i-esimo elemento.;Un arreglo es una buena alternativa para implementar un lista cuando NO necesitamos o eliminar elementos intermedios.;El arreglo ofrece ventajas y desventajas al compararse con una lista enlazada doble.
El arreglo permite una eliminacion mas eficiente/rapida del i-esimo elemento.;El arreglo es mucho mas eficiente/rapido a la hora de buscar un dato determinado.;Un arreglo generalmente ocupa menos memoria que la lista enlazada.;Las lista enlazada doble circular es la estructura mas recomendada para implementar una Lista.
205;En relacion a la implementacion usando arreglos se puede decir que:
Al implementar una pila, el arreglo se va llenando de izquierda a derecha.;Un arreglo se transforma en CIRCULAR si consideramos que luego de la ultima casilla volvemos a la primera.;Cuando insertamos un dato en un arreglo lleno, debemos redimensionarlo.;Se suelen utilizar para implementar pilas y colas.;Al implementar una cola usando arreglos, cuando se llena el arreglo, es necesario aumentar su capacidad y reubicar los elementos.;Al implementar una cola usando arreglos, cuando se inserta un elemento, el indice del final se corre a la izquierda.
Al implementar una cola usando arreglos, para eliminar un elemento debemos mover todos los elementos que siguen una posicion hacia la izquierda.;Al implementar una pila, el elemento top corresponde al primer elemento del arreglo.;Para eliminar un elemento de un arreglo es necesario cambiar su valor a NULL.;Son mejores que las listas enlazadas.;Cuando insertamos un dato en un arreglo siempre debemos redimensionarlo.;Cuando eliminamos un dato de un arreglo debemos redimensionarlo.;Al implementar una cola usando arreglos, cuando se elimina un elemento, el indice del inicio se debe correr hacia la izquierda.;Al implementar una cola usando arreglos, cuando el indice del inicio llega a 0 y se borra un elemento es necesario cambiarlo a N-1.
206;En relacion a la implementacion de colas y pilas usando arreglos, es incorrecto decir que:
En la cola se usa un puntero al final para acceder al ultimo elemento.
En ambos casos se hace uso de indices para indicar posiciones clave (ejemplo: comienzo, fin, top).;Para implementar una cola se puede usar un arreglo circular.;Para implementar la pila, los elementos se ordenan de izquierda a derecha en el arreglo.
301;Indique cual de los siguientes enunciados es falso:
Hacer un bucle que itera n veces sobre otro bucle que realiza m iteraciones tiene complejidad O(n+m).;La complejidad temporal de 1000nlogn + n^2 es O(nlogn).;Eliminar el primer dato de una lista enlazada simple tiene complejidad O(n).;La busqueda binaria en un arreglo ordenado tiene complejidad O(nlogn).;Insertar n elementos ordenados en una lista enlazada tiene complejidad O(n).;El algoritmo mas eficiente para sumar los elementos de la secuencia: 1+2+…+n tiene complejidad O(n^2).;El algoritmo mas eficiente para ordenar un conjunto de datos tiene complejidad O(n).;La complejidad de insertar un elemento en una cola es O(n).;La complejidad temporal de 3n^2+m^2 es O(n+m).;La eliminacion de un nodo apuntado por el current en una lista enlazada simple tiene complejidad O(1).
La complejidad de 2 bucles llamados de manera secuencial es igual a la complejidad del bucle con mayor complejidad.;La complejidad temporal de 5^n+n^5 es O(5^n).;Ordenar los datos de una lista enlazada usando el ordenamiento burbuja tiene complejidad O(i).;Llamar 10 veces a una funcion con complejidad lineal tiene complejidad O(n).;La complejidad temporal de n+n^2+n^3 es O(n^3).;La complejidad de un bucle for(i=0 (puntoComa) i<n (puntoComa) i=i x 2) que en cada iteracion llama a una operacion con complejidad lineal tiene complejidad O(nlogn).;Llamar n veces a una funcion con complejidad constante tiene complejidad O(n).;Buscar el mayor elemento en un arreglo ordenado tiene complejidad O(1).;Acceder al i-esimo dato de una lista enlazada tiene complejidad O(i).;La complejidad temporal de 5(n+1)/(n−1) es O(1).;La complejidad temporal de n+n^2+n^3 es O(n^3).;La operacion calloc tiene complejidad lineal en el tamanho del arreglo.
302;En relacion a la tabla hash podemos decir que:
Almacena datos de manera desordenada.;La funcion hash permite saber la posicion en donde deberia encontrarse un dato.;Tener una tabla hash con un porcentaje ocupado por sobre el recomendable, puede provocar un aumento considerable en el numero colisiones.;Es eficiente en la busqueda.;Entre mas elementos tenga la tabla hash, mayor es la probabilidad de que ocurran colisiones.;Es conveniente agrandar la tabla hash antes de que llegue a su capacidad.
Es eficiente en la busqueda de datos ordenados.;La funcion hash agranda la tabla cuando se ocupan todas las casillas disponibles.;Es conveniente ocupar toda la capacidad de la tabla, para utilizar toda la memoria disponible.
303;En relacion a la busqueda en una tabla hash podemos decir que:
Hace uso de la funcion hash y de un metodo de resolucion de colisiones.;En caso de colision, debe aplicar el mismo metodo de resolucion de colisiones utilizado en la insercion.;Se detiene al llegar a una casilla vacia.;Antes de retornar un dato debe verificar que la clave coincida con la que se busca.;Su complejidad temporal promedio es O(1), ya que la funcion hash permite encontrar rapidamente la posicion en donde probablemente se encuentra el dato.;Al llegar a una casilla vacia, el metodo asegura que el dato no se encuentra en la tabla.
Su complejidad temporal es O(log n) ya que los datos se encuentran ordenados.;Retorna directamente el dato que se encuentra en la posicion entregada por la funcion hash.;En caso de colision, su complejidad temporal es lineal (en promedio) ya que se debe recorrer el arreglo hasta encontrar el dato.;Se detiene al llegar a un dato con clave distinta a la que se busca.;Antes de retornar un dato debe verificar que el valor coincida con la que se busca.
304;En relacion al TDA Mapa podemos decir que:
No permiten almacenar claves repetidas.;Para almacenar datos con claves repetidas, se pueden usar listas para agrupar estos datos.;Se puede implementar usando una lista enlazada, aunque seria bastante lento en realizar operaciones.;Se puede usar para clasificar datos en distintas categorias.;Es recomendable usarlo cuando necesitamos buscar elementos en base a un criterio determinado.;Se puede usar para contar las ocurrencias de palabras en un texto.;La eficiencia temporal de sus operaciones depende de su implementacion.;Un metodo de resolucion de colisiones podria consistir en buscar la siguiente casilla vacia a partir de la retornada por la funcion hash.
Es recomendable usarlo si queremos almacenar elementos con una secuencia determinada.;Es recomendable usarlo si queremos acceder rapidamente al ultimo elemento ingresado.;Es recomendable debido a la rapidez de sus operaciones.
305;En relacion a las colisiones en la tabla hash podemos decir que:
Si el metodo de resolucion de colisiones encuentra una casilla nula, quiere decir que el dato no existe.;Las colisiones ocurren cuando la funcion hash nos entrega la posicion de una casilla ocupada.;Existen distintos metodos de resolucion de colisiones.;Si hay colision se aplica un metodo para resolver el problema.
Si al insertar un dato se produce una colision, se crea un nuevo nodo e inserta el dato al final de la tabla.;Si hay colision se aumenta el tamanho de la tabla.;Si al insertar un dato se produce una colision, entonces se sobreescribe el dato de la tabla.;Ocurre cuando se insertan dos claves iguales en la tabla.;Esto no puede ocurrir. La funcion retorna valores distintos para claves distintas.
306;En relacion a la funcion hash podemos decir que:
Retorna un numero entero.;Una buena funcion hash dispersa los datos dentro de la tabla.;Una funcion hash valida consiste en retornar una constante (por ejemplo: return 0).;Una buena funcion hash consiste en multiplicar la clave por un numero decimal y luego usar los decimales del resultado para obtener el valor.;Retorna una posicion para el dato que se quiere ingresar.;Transforma una variable en un numero entero.
Retorna la clave del dato que se quiere ingresar.;Busca una casilla disponible (vacia) para insertar el dato.;Una funcion hash podria consistir en retornar un numero aleatorio.;Puede retornar cualquier tipo de dato (void (puntero)).;Una buena funcion hash no genera colisiones.;Una buena funcion hash no deberia causar colisiones.
401;En relacion a las distintas estructuras vistas hasta ahora podemos decir que:
Conviene utilizar una tabla hash cuando solo queremos realizar busquedas;Un arbol AVL es mas rapido que un arbol rojo-negro para realizar busquedas;El comportamiento de un multimapa se puede IMITAR usando un mapa de listas;Comparado Con una tabla hash, una ventaja del arbol AVL es que puede mostrar los datos ordenados por clave
Un arbol AVL es mas rapido que un arreglo ordenado para realizar busquedas;Si queremos cambiar el valor de un elemento insertado en un Mapa, debemos obtener el elemento, eliminarlo del Mapa, cambiar su valor y volver a insertarlo;Un arreglo ordenado es mas rapido que un arbol rojo-negro para realizar eliminaciones
402;En relacion al arbol binario de busqueda, tabla hash y mapas podemos decir que:
Una tabla hash se puede usar para implementar un multimapa (mapa que permite claves repetidas);Un mapa se puede implementar usando una lista enlazada simple aunque no seria muy eficiente.;La busqueda en un tabla hash es mas rapida que la busqueda en un arbol binario de busqueda.;Un multimapa (mapa que permite claves repetidas) se puede implementar usando un arbol binario de busqueda.
El mapa ordenado, al igual que el mapa, utiliza la funcion hash para generar claves.;Un mapa ordenado permite almacenar 2 elementos distintos con claves iguales.;Un arbol binario de busqueda se puede implementar usando listas enlazadas.;Conviene utilizar una tabla hash, cuando solo queremos realizar busquedas por rango.;Una tabla hash se puede usar para implementar un mapa ordenado.
403;En relacion a la complejidad temporal en un arbol binario de busqueda es correcto decir que:
Si todos los nodos tienen un solo hijo, se produce el peor caso para las operaciones del arbol.;La complejidad de obtener el nodo raiz es O(1);La complejidad promedio de la busqueda por rango es O(log n+m) porque se debe realizar una busqueda inicial con complejidad O(log n) y luego se debe avanzar por los m elementos del rango.;La busqueda tiene complejidad O(log n) ya que en cada paso el subarbol que se busca se reduce a la mitad.;Para buscar se desciende preguntando si la clave buscada es mayor o menor a la del nodo actual.;Si todos los nodos tuvieran un hijo, la complejidad promedio de la busqueda seria O(n);La complejidad de obtener el nodo raiz es O(1)
La complejidad temporal de la eliminacion es O(n) ya que es necesario pasar por todos los nodos.;La insercion tiene complejidad O(log n) ya que hay que pasar por la mitad de los nodos dependiendo si es mayor o menor;La complejidad promedio de obtener el primer dato (menor clave) del arbol es O(1);Para la eliminacion, el peor caso ocurre al eliminar el nodo raiz ya que es necesario reestructurar todo el arbol.;El peor caso de la busqueda ocurre cuando esta lleno y es necesario asignarle memoria adicional
404;En relacion a los arboles AVL y rojo-negro, podemos decir que:
Ambos arboles tienen que cumplir una serie de reglas para mantener una baja altura;en general, el arbol AVL realiza mas rotaciones que el arbol rojo-negro;En el arbol AVL, en el peor caso la numero de rotaciones que se realizan al insertar un dato es cercana a la altura del arbol.;En un arbol rojo-negro, ademas de realizar rotaciones, los nodos pueden cambiar de color;El arbol AVL es mas rapido para busquedas
El tiempo (cantidad de instrucciones) que tarda realizar una rotacion depende de la altura del arbol;En la fase de rotacion, se revisan todos los nodos del arbol y se rebalancean los que se encuentran desequilibrados.;El factor de equilibrio es igual a la diferencia de la cantidad de nodos entre la rama derecha y la izquierda de un arbol binario;Un arbol AVL debe tener un factor de equilibrio igual a +1 en el nodo raiz;La altura de un arbol rojo-negro es, en general, menor a la de un arbol AVL;Las rotaciones se realizan luego de buscar un dato.
405;En relacion a los TDAs vistos hasta ahora, podemos decir que:
Un Mapa puede servir como contador de palabras repetidas;El comportamiento de un multimapa se puede iMITAR usando un mapa de listas;Suponiendo que nuestra impresora esta configurada usando una Pila de impresion (en vez de una cola), nos convendraa enviar los documentos justo antes que la impresora termine de imprimir el documento actual;Si queremos cambiar la clave de un elemento insertado en un Mapa, debemos obtener el elemento, eliminarlo del Mapa, cambiar su clave y volver a insertarlo;Las operaciones de una Lista engloban las operaciones de Pilas y Colas
Un Mapa es mejor que una Lista;Para implementar un editor de texto que nos permita deshacer las ultimas palabras escritas, nos convendria usar una cola para ir almacenando las palabras y acceder a la ultima escrita;Si queremos cambiar el valor de un elemento insertado en un Mapa, debemos obtener el elemento, eliminarlo del Mapa, cambiar su valor y volver a insertarlo;Un programa implementado usando Pilas, tambien se puede implementar usando Colas.
406;Al comparar un arbol binario de busqueda con otras estructuras de datos, podemos decir que:
Realizar busquedas usando claves es mas rapido que en una lista enlazada doble.;Comparado con un arreglo ordenado, la principal ventaja del arbol es la eficiencia en las operaciones de insercion/eliminacion.;Su complejidad espacial es igual a la de una tabla hash.;Si los elementos son insertados en orden, la complejidad temporal de la busqueda en el arbol es comparable a la de una lista enlazada simple.;Las busquedas por rango son mas eficientes que en una tabla hash.;Su complejidad espacial es igual a la de una lista enlazada.
La gran ventaja del arbol con respecto a la tabla hash es que no ocurren colisiones.;Permite realizar las mismas operaciones que una lista enlazada simple (inserciones al principio, al final o entremedio);Se pueden realizar busquedas mas rapido que en un arreglo ordenado.;Es mas rapido que una tabla hash al realizar busqueda por claves.;Las busquedas son mas rapidas que en una tabla hash.;La complejidad temporal de su busqueda es igual a la de la tabla hash.
407;En relacion a las distintas estructuras de datos vistas durante el curso, podemos decir que:
Al incrementar la capacidad de la tabla hash, es necesario volver a insertar todos sus elementos;Al incrementar la capacidad de la tabla hash, es necesario volver a insertar todos sus elementos;Para implementar una cola usando un arreglo circular, necesitamos mantener al menos dos indices;Si asumimos que la operacion malloc ene complejidad O(1). Aumentar la capacidad de un arreglo que implementa una pila ene complejidad temporal peor caso O(1);Cuando los datos en un arreglo son mucho menores a su capacidad, se podria reducir la capacidad del arreglo para asi ahorrar memoria  
Una tabla hash es mas conveniente que una lista enlazada si queremos implementar una Lista;Se recomienda aumentar la capacidad de la tabla en un 1, para reducir la complejidad temporal de la operacion;Para implementar una cola usando un arreglo circular, necesitamos mantener al menos dos andices;La tabla hash se debe agrandar cuando alcanza el 100% de su capacidad
408;En relacion a la complejidad temporal podemos decir que:
La complejidad temporal de la busqueda en el arbol rojo-negro es O(log n), ya que mantiene su altura acotada.;Las rotaciones tienen complejidad temporal O(1).;El numero de rotaciones del arbol rojo-negro tiene complejidad constante;La cantidad de rotaciones que realiza el arbol AVL en una insercion puede ser O(log n) en el peor caso.;Las busquedas en el arbol AVL son mas rapidas que en el rojo-negro. Sin embargo, en ambos casos la complejidad temporal es la misma.
La complejidad temporal de la insercion en el arbol AVL es O(n), debido a las rotaciones.;El arbol rojo-negro realiza O(log n) rotaciones por insercion.;Las rotaciones tienen complejidad temporal O(log n).;El peor caso de la busqueda en un arbol rojo-negro es O(2 x log n).
409;En relacion a los arboles binarios de busqueda, indique la opcion verdadera
Para buscar se desciende preguntando si la clave buscada es mayor o menor a la del nodo actual.;Para eliminar los datos de un nodo con dos hijos, los datos son reemplazados por los de otro nodo (que tiene uno o ningun hijo), y luego se elimina el otro nodo.;El menor elemento se encuentra en la parte mas izquierda del arbol.;En caso de que el current tenga un hijo derecho, la operacion next siempre retorna la minima clave del subarbol derecho.
La clave del nodo raiz coincide con la mediana de las claves.;En caso de colision se deben revisar los hijos del nodo hasta llegar a una hoja.;La funcion hash retorna el nodo en donde se debe insertar el dato.;Si hay otro dato en esa posicion, se baja por el arbol hasta llegar a un nodo hoja y alli se inserta el dato.;En caso de que el current tenga un hijo derecho, la operacion next siempre retorna la minima clave del subarbol derecho.
410;Con respecto a los arboles auto-balanceables podemos decir que
Un arbol auto-balanceable intenta mantener su altura lo mas bajo posible.;La altura del arbol de busqueda influye en la eficiencia de sus operaciones;Un arbol auto-balanceable utiliza las rotaciones para mantener una baja altura;Un arbol auto-balanceable tiene menor altura (en promedio) que un arbol no auto-balanceable.
En un arbol auto-balanceable, las inserciones y eliminaciones son siempre mas lentas que un arbol no auto-balanceable debido a las rotaciones.;En un arbol auto-balanceable, el recorrido (de menor a mayor) se realiza mas rapido que en un arbol no auto-balanceable;En un arbol auto-balanceable, las inserciones son siempre mas rapidas que en un arbol no auto-balanceable.
411;En relacion a los arboles biselados podemos decir que:
Si el dato buscado se encuentra a una misma profundidad, la busqueda sera mas lenta en el arbol biselado en comparacion a otros tipos de arbol.;La biselacion es un mecanismo que funciona en base a rotaciones.
Gracias al proceso de biselacion, las busquedas en el arbol biselado son siempre mas rapidas que en los otros arboles auto-balanceables.;Las reglas de balanceo del arbol biselado son mas estrictas que las del arbol rojo-negro, pero menos estrictas que las del arbol AVL.;La biselacion de un nodo se realiza solo al buscar un dato.;Los arboles biselados tiene complejidad temporal de busqueda O(log n) en el peor caso.
501;En relacion a la cola con prioridad podemos decir que:
Es adecuada si queremos acceder (modificar/eliminar) el dato con mayor indice de prioridad.;Se puede usar para almacenar nodos al recorrer un grafo. La cola permitiria seleccionar el nodo mas prometedor en cada iteracion.;Insertar es una operacion fundamental en una cola.;Podria ser implementada de manera eficiente usando un arbol binario de busqueda.
Es adecuada para buscar datos por prioridad.;Es una estructura de datos que permite acceder al dato con mayor prioridad con complejidad O(1).;Es eficiente para realizar busquedas por prioridad: O (log n).
502;En relacion a un monticulo binario de maximos podemos decir que:
Es un arbol binario que se implementa usando un arreglo.;El monticulo es altamente efectivo cuando lo unico que necesito es guardar datos y acceder o eliminar el que tiene mayor prioridad.;El segundo mayor elemento deberia encontrarse en el segundo nivel del arbol (justo por debajo del nodo raiz).;En el caso promedio, la insercion es O(1).
Encontrar tanto el mayor como el menor elemento se realiza de manera mas eficiente que la eliminacion.;Es eficiente para realizar busquedas por prioridad.;Comparado con un arreglo ordenado por prioridad, la ventaja del monticulo tiene que ver con la eliminacion de elementos.
503;En relacion al arbol B/B+ es correcto decir que:
Al eliminar, es posible que se produzcan fusiones entre nodos hermanos.;El camino desde la raiz a cualquier clave tiene la misma longitud.;La eliminacion de un dato en un arbol B tiene complejidad temporal promedio O(log N).;Se recomienda usar un arbol B cuando se tienen datos de gran tamanho y no caben en la memoria principal (ejemplo fotografias, videos, musica).
Es recomendable usar un arbol B/B+ cuando los nodos del arbol se encuentran almacenados en la memoria principal(disco duro).;Debido a su baja altura, la eliminacion en un arbol es mas eficiente que la insercion.;Al insertar en un arbol B/B+ se generan nuevos nodos hoja.
504;Indique la alternativa verdadera.
El peor caso para un arbol de busqueda no balanceado ocurrira si insertamos los datos en orden creciente o decreciente.;La operacion next de una tabla hash, de una lista y de un arbol binario tienen la misma complejidad temporal promedio: O(1).;Buscar una prioridad especifica en un monticulo binario de maximos tiene complejidad O(N).;La cola por prioridad puede ser usada para gestion de impresiones enviadas.
Es recomendable usar arbol B/B+ cuando si los nodos se encuentran almacenados en la RAM.;Los nodos hojas son los nodos que se encuentran al inicio de cada rama.;La cola por prioridad puede ser usada como lista enlazada.