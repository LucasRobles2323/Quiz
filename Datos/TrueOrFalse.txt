Todas las variables locales se almacenan en la misma zona de memoria.;Los datos de un arreglo se almacenan en memoria de manera consecutiva.;En un arreglo a[10], a es un puntero que apunta a la primera casilla del arreglo.;Para pasar datos por referencia en funciones se necesitan punteros.;Un puntero es un tipo de dato que almacena la direccion de memoria de otra variable.; int a[20] crea un arreglo de 20 enteros.;Se pueden inicializar los arreglos de manera estatica o dinamica.;En un arreglo, a[2] es equivalente a *(a+2).;Para inicializar un arreglo de manera dinamica se debe reservar la memoria correspondiente en la zona de memoria Heap.;En un arreglo a[10], a es un puntero que apunta a la primera casilla del arreglo.;Buscar un dato especifico en una lista enlazada requiere recorrer la lista.;Eliminar el ultimo elemento de una lista enlazada circular requiere recorrer la lista enlazada circular.;Para insertar al principio en una lista enlazada simple no es necesario recorrer dicha lista.;;Insertar un elemento al final en una lista enlazada circular no requiere recorrer la lista enlazada circular.;Insertar al final en un arreglo circular no requiere que se recorrar dicho arreglo.;Un arreglo es una buena alternativa para implementar pilas y colas.
Para asignar a un puntero int* a, la direccion de una variable int b, hacemos: a=*b.;Los punteros son un tipo de dato abstracto.;Las variables definidas en la funcion main son globales, por lo que se almacenan en la zona static.;int* a[10] crea un arreglo de 10 enteros.;Los punteros permiten el paso de datos por valor a funciones.; Al modificar la direccion referenciada por un puntero, tambien se modifica la direccion del dato referenciado.;En la zona de memoria “stack” es posible que se formen huecos de memoria sin reservar.;La operacion malloc permite inicializar un arreglo con ceros (0).;Luego de terminar de usar un arreglo estatico es necesario liberar la memoria usando free.;Arreglos estaticos se almacenan en la zona de memoria Heap.;Los arreglos se deben pasad a las funciones por valor.;El error “stack overflow” ocurre cuando se generan demasiadas variables locales llenando el Stack de memoria.;Insertar entremedio en un arreglo no requiere recorrer el arreglo.;Acceder al i-esimo elemento en un arreglo requiere recorrer el arreglo completo.;Insertar un elemento en una cola requiere recorrer la cola.;El arreglo permite una eliminacion mas eficiente/rapida del i-esimo elemento que la lista enlazada.


204;Al comparar arreglos y listas enlazadas a la hora de implementar una Lista, se puede decir que:
;El arreglo permite un acceso mas eficiente/rapido al i-esimo elemento.;Un arreglo es una buena alternativa para implementar un lista cuando NO necesitamos o eliminar elementos intermedios.;El arreglo ofrece ventajas y desventajas al compararse con una lista enlazada doble.
;El arreglo es mucho mas eficiente/rapido a la hora de buscar un dato determinado.;Un arreglo generalmente ocupa menos memoria que la lista enlazada.;Las lista enlazada doble circular es la estructura mas recomendada para implementar una Lista.
205;En relacion a la implementacion usando arreglos se puede decir que:
Al implementar una pila, el arreglo se va llenando de izquierda a derecha.;Un arreglo se transforma en “circular” si consideramos que luego de la ultima casilla volvemos a la primera.;Cuando insertamos un dato en un arreglo lleno, debemos redimensionarlo.;Se suelen utilizar para implementar pilas y colas.;Al implementar una cola usando arreglos, cuando se llena el arreglo, es necesario aumentar su capacidad y reubicar los elementos.;Al implementar una cola usando arreglos, cuando se inserta un elemento, el indice del final se corre a la izquierda.
Al implementar una cola usando arreglos, para eliminar un elemento debemos mover todos los elementos que siguen una posicion hacia la izquierda.;Al implementar una pila, el elemento top corresponde al primer elemento del arreglo.;Para eliminar un elemento de un arreglo es necesario cambiar su valor a NULL.;Son mejores que las listas enlazadas.;Cuando insertamos un dato en un arreglo siempre debemos redimensionarlo.;Cuando eliminamos un dato de un arreglo debemos redimensionarlo.;Al implementar una cola usando arreglos, cuando se elimina un elemento, el indice del inicio se debe correr hacia la izquierda.;Al implementar una cola usando arreglos, cuando el indice del inicio llega a 0 y se borra un elemento es necesario cambiarlo a N-1.
206;En relacion a la implementacion de colas y pilas usando arreglos, es incorrecto decir que:
En la cola se usa un puntero al final para acceder al ultimo elemento.
En ambos casos se hace uso de indices para indicar posiciones clave (ejemplo: comienzo, fin, top).;Para implementar una cola se puede usar un arreglo circular.;Para implementar la pila, los elementos se ordenan de izquierda a derecha en el arreglo.
301;Indique cual de los siguientes enunciados es falso:
Hacer un bucle que itera n veces sobre otro bucle que realiza m iteraciones tiene complejidad O(n+m).;La complejidad temporal de 1000nlogn + n^2 es O(nlogn).;Eliminar el primer dato de una lista enlazada simple tiene complejidad O(n).;La busqueda binaria en un arreglo ordenado tiene complejidad O(nlogn).;Insertar n elementos ordenados en una lista enlazada tiene complejidad O(n).;El algoritmo mas eficiente para sumar los elementos de la secuencia: 1+2+…+n tiene complejidad O(n^2).;El algoritmo mas eficiente para ordenar un conjunto de datos tiene complejidad O(n).;La complejidad de insertar un elemento en una cola es O(n).;La complejidad temporal de blanco3n^2+m^2 es blancoO(n+m).;La eliminacion de un nodo apuntado por el current en una lista enlazada simple tiene complejidad O(1).
La complejidad de 2 bucles llamados de manera secuencial es igual a la complejidad del bucle con mayor complejidad.;La complejidad temporal de 5^n+n^5 es O(5^n).;Ordenar los datos de una lista enlazada usando el ordenamiento burbuja tiene complejidad O(i).;Llamar 10 veces a una funcion con complejidad lineal tiene complejidad O(n).;La complejidad temporal de n+n^2+n^3 es O(n^3).;La complejidad de un bucle for(i=0;i<n;i=i*2) que en cada iteracion llama a una operacion con complejidad lineal tiene complejidad O(nlogn).;Llamar n veces a una funcion con complejidad constante tiene complejidad O(n).;Buscar el mayor elemento en un arreglo ordenado tiene complejidad O(1).;Acceder al i-esimo dato de una lista enlazada tiene complejidad O(i).;La complejidad temporal de 5(n+1)/(n−1) es O(1).;La complejidad temporal de n+n^2+n^3 es O(n^3).;La operacion calloc tiene complejidad lineal en el tamanho del arreglo.
302;En relacion a la tabla hash podemos decir que:
Almacena datos de manera desordenada.;La funcion hash permite saber la posicion en donde deberia encontrarse un dato.;Tener una tabla hash con un porcentaje ocupado por sobre el recomendable, puede provocar un aumento considerable en el numero colisiones.;Es eficiente en la busqueda.;Entre mas elementos tenga la tabla hash, mayor es la probabilidad de que ocurran colisiones.;Es conveniente agrandar la tabla hash antes de que llegue a su capacidad.
Es eficiente en la busqueda de datos ordenados.;La funcion hash agranda la tabla cuando se ocupan todas las casillas disponibles.;Es conveniente ocupar toda la capacidad de la tabla, para utilizar toda la memoria disponible.
303;En relacion a la busqueda en una tabla hash podemos decir que:
Hace uso de la funcion hash y de un metodo de resolucion de colisiones.;En caso de colision, debe aplicar el mismo metodo de resolucion de colisiones utilizado en la insercion.;Se detiene al llegar a una casilla vacia.;Antes de retornar un dato debe verificar que la clave coincida con la que se busca.;Su complejidad temporal promedio es O(1), ya que la funcion hash permite encontrar rapidamente la posicion en donde probablemente se encuentra el dato.;Al llegar a una casilla vacia, el metodo asegura que el dato no se encuentra en la tabla.
Su complejidad temporal es O(log n) ya que los datos se encuentran ordenados.;Retorna directamente el dato que se encuentra en la posicion entregada por la funcion hash.;En caso de colision, su complejidad temporal es lineal (en promedio) ya que se debe recorrer el arreglo hasta encontrar el dato.;Se detiene al llegar a un dato con clave distinta a la que se busca.;Antes de retornar un dato debe verificar que el valor coincida con la que se busca.
304;En relacion al TDA Mapa podemos decir que:
No permiten almacenar claves repetidas.;Para almacenar datos con claves repetidas, se pueden usar listas para agrupar estos datos.;Se puede implementar usando una lista enlazada, aunque seria bastante lento en realizar operaciones.;Se puede usar para clasificar datos en distintas categorias;Es recomendable usarlo cuando necesitamos buscar elementos en base a un criterio determinado.;Se puede usar para contar las ocurrencias de palabras en un texto.;La eficiencia temporal de sus operaciones depende de su implementacion.;Un metodo de resolucion de colisiones podria consistir en buscar la siguiente casilla vacia a partir de la retornada por la funcion hash.
Es recomendable usarlo si queremos almacenar elementos con una secuencia determinada.;Es recomendable usarlo si queremos acceder rapidamente al ultimo elemento ingresado.;Es recomendable debido a la rapidez de sus operaciones.
305;En relacion a las colisiones en la tabla hash podemos decir que:
Si el metodo de resolucion de colisiones encuentra una casilla nula, quiere decir   que el dato no existe.;Las colisiones ocurren cuando la funcion hash nos entrega la posicion de una casilla ocupada.;Existen distintos metodos de resolucion de colisiones.;Si hay colision se aplica un metodo para resolver el problema.
Si al insertar un dato se produce una colision, se crea un nuevo nodo e inserta el dato al final de la tabla.;Si hay colision se aumenta el tamanho de la tabla.;Si al insertar un dato se produce una colision, entonces se sobreescribe el dato de la tabla.;Ocurre cuando se insertan dos claves iguales en la tabla.;Esto no puede ocurrir. La funcion retorna valores distintos para claves distintas.
306;En relacion a la funcion hash podemos decir que:
Retorna un numero entero.;Una buena funcion hash dispersa los datos dentro de la tabla.;Una funcion hash valida consiste en retornar una constante (por ejemplo: return 0).;Una buena funcion hash consiste en multiplicar la clave por un numero decimal y luego usar los decimales del resultado para obtener el valor.;Retorna una posicion para el dato que se quiere ingresar.;Transforma una variable en un numero entero.
Retorna la clave del dato que se quiere ingresar.;Busca una casilla disponible (vacia) para insertar el dato.;Una funcion hash podria consistir en retornar un numero aleatorio.;Puede retornar cualquier tipo de dato (void*).;Una buena funcion hash no genera colisiones.;Una buena funcion hash no deberia causar colisiones.
501;En relacion a la cola con prioridad podemos decir que:
Es adecuada si queremos acceder (modificar/eliminar) el dato con mayor indice de prioridad.;Se puede usar para almacenar nodos al recorrer un grafo. La cola permitiria seleccionar el nodo "mas prometedor" en cada iteracion.;"Insertar" es una operacion fundamental en una cola.;Podria ser implementada de manera eficiente usando un arbol binario de busqueda.
Es adecuada para buscar datos por prioridad.;Es una estructura de datos que permite acceder al dato con mayor prioridad con complejidad O(1).;Es eficiente para realizar busquedas por prioridad: O (log n).
502;En relacion a un monticulo binario de maximos podemos decir que:
Es un arbol binario que se implementa usando un arreglo.;El monticulo es altamente efectivo cuando lo unico que necesito es guardar datos y acceder o eliminar el que tiene mayor prioridad.;El segundo mayor elemento deberia encontrarse en el segundo nivel del arbol (justo por debajo del nodo raiz).;En el caso promedio, la insercion es O(1).
Encontrar tanto el mayor como el menor elemento se realiza de manera mas eficiente que la eliminacion.;Es eficiente para realizar busquedas por prioridad.;Comparado con un arreglo ordenado por prioridad, la ventaja del monticulo tiene que ver con la eliminacion de elementos.
503;En relacion al arbol B/B+ es correcto decir que:
Al eliminar, es posible que se produzcan "fusiones" entre nodos hermanos.;El camino desde la raiz a cualquier clave tiene la misma longitud.;La eliminacion de un dato en un arbol B tiene complejidad temporal promedio O(log N).;Se recomienda usar un arbol B cuando se tienen datos de gran tamanho y no caben en la memoria principal (ejemplo fotografias, videos, musica).
Es recomendable usar un arbol B/B+ cuando los nodos del arbol se encuentran almacenados en la memoria principal(disco duro).;Debido a su baja altura, la eliminacion en un arbol es mas eficiente que la insercion.;Al insertar en un arbol B/B+ se generan nuevos nodos hoja.
504;Indique la alternativa verdadera.
El peor caso para un arbol de busqueda no balanceado ocurrira si insertamos los datos en orden creciente o decreciente.;La operacion next de una tabla hash, de una lista y de un arbol binario tienen la misma complejidad temporal promedio: O(1).;Buscar una prioridad especifica en un monticulo binario de maximos tiene complejidad O(N).;La cola por prioridad puede ser usada para gestion de impresiones enviadas.
Es recomendable usar arbol B/B+ cuando si los nodos se encuentran almacenados en la RAM.;Los nodos hojas son los nodos que se encuentran al inicio de cada rama.;La cola por prioridad puede ser usada como lista enlazada.